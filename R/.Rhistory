if (!is.null(X.text.col) && is.matrix(X.text.col) &&
(nrow(X.text.col) == nrow(X)) &&
(ncol(X.text.col) == ncol(X))) {
X.text.col <- X.text.col[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.size) && is.matrix(X.text.size) &&
(nrow(X.text.size) == nrow(X)) &&
(ncol(X.text.size) == ncol(X))) {
X.text.size <- X.text.size[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.angle) && is.matrix(X.text.angle)) {
X.text.angle <- X.text.angle[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(yr)) {
# only rearrange within cluster if the right plot is for each
# data point (rather than for each cluster)
if (length(yr) == nrow(X)) {
yr <- yr[order.df.rows$order.rows]
yr.obs.col <- yr.obs.col[order.df.rows$order.rows]
}
}
if (!is.null(yt)) {
# only rearrange within cluster if the top plot is for each
# data point (rather than for each cluster)
if (length(yt) == ncol(X)) {
yt <- yt[order.df.cols$order.cols]
yt.obs.col <- yt.obs.col[order.df.cols$order.cols]
}
}
# rearrange bar colors if needed
if (!is.null(yt.bar.col) && (length(yt.bar.col) == ncol(order.df.cols))) {
yt.bar.col <- yt.bar.col[order.df.cols$order.cols]
}
if (!is.null(yr.bar.col) && (length(yr.bar.col) == nrow(order.df.rows))) {
yr.bar.col <- yr.bar.col[order.df.rows$order.rows]
}
# rearrange label colors if needed
if (!is.null(left.label.col)) {
left.label.col <- left.label.col[order.df.rows$order.rows]
}
if (!is.null(bottom.label.col)) {
bottom.label.col <- bottom.label.col[order.df.cols$order.cols]
}
# rearrange label text colors if needed
if (!is.null(left.label.text.col)) {
left.label.text.col <- left.label.text.col[order.df.rows$order.rows]
}
if (!is.null(bottom.label.text.col)) {
bottom.label.text.col <- bottom.label.text.col[order.df.cols$order.cols]
}
# the default if clustering was not performed
if (ncol(X) == 1) {
membership.cols <- 1
}
if (!cluster.cols & ncol(X) > 1) {
membership.cols <- 1:ncol(X)
} else {
membership.cols <- membership.cols[order.df.cols$order.cols]
}
X
dim(X)
X <- as.matrix(c(1, 2, 3))
X
# clean the matrix X
X <- clean_matrix(X, scale)
X
dim(X)
order.df.cols$order.cols
order.df.rows$order.rows
X[order.df.rows$order.rows, order.df.cols$order.cols]
devtools::load_all()
X <- as.matrix(c(1, 2, 3))
superheat(X)
X
nrow(X)
ncol(X)
nrow(X) > 1 & ncol(X) > 1
nrow(X) == 1
X[order.df.rows$order.rows, ]
as.matrix(X[order.df.rows$order.rows, ])
as.matrix(X[, order.df.cols$order.cols])
devtools::load_all()
X <- as.matrix(c(1, 2, 3))
superheat(X)
if (nrow(X) == 1) {
X <- as.matrix(X[, order.df.cols$order.cols])
}
X <- as.matrix(X[order.df.rows$order.rows, ])
if (nrow(X) == 1) {
X <- as.matrix(X[, order.df.cols$order.cols])
}
devtools::load_all()
X <- as.matrix(c(1, 2, 3))
superheat(X)
# Reorder X matrices, yr and yt based on the new ordering
if (ncol(X) == 1) {
X <- as.matrix(X[order.df.rows$order.rows, ], drop = FALSE)
}
if (nrow(X) == 1) {
X <- as.matrix(X[, order.df.cols$order.cols], drop = FALSE)
}
if (nrow(X) > 1 & ncol(X) > 1) {
X <- X[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text) && is.matrix(X.text) &&
(nrow(X.text) == nrow(X)) &&
(ncol(X.text) == ncol(X))) {
X.text <- X.text[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.col) && is.matrix(X.text.col) &&
(nrow(X.text.col) == nrow(X)) &&
(ncol(X.text.col) == ncol(X))) {
X.text.col <- X.text.col[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.size) && is.matrix(X.text.size) &&
(nrow(X.text.size) == nrow(X)) &&
(ncol(X.text.size) == ncol(X))) {
X.text.size <- X.text.size[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.angle) && is.matrix(X.text.angle)) {
X.text.angle <- X.text.angle[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(yr)) {
# only rearrange within cluster if the right plot is for each
# data point (rather than for each cluster)
if (length(yr) == nrow(X)) {
yr <- yr[order.df.rows$order.rows]
yr.obs.col <- yr.obs.col[order.df.rows$order.rows]
}
}
if (!is.null(yt)) {
# only rearrange within cluster if the top plot is for each
# data point (rather than for each cluster)
if (length(yt) == ncol(X)) {
yt <- yt[order.df.cols$order.cols]
yt.obs.col <- yt.obs.col[order.df.cols$order.cols]
}
}
# rearrange bar colors if needed
if (!is.null(yt.bar.col) && (length(yt.bar.col) == ncol(order.df.cols))) {
yt.bar.col <- yt.bar.col[order.df.cols$order.cols]
}
if (!is.null(yr.bar.col) && (length(yr.bar.col) == nrow(order.df.rows))) {
yr.bar.col <- yr.bar.col[order.df.rows$order.rows]
}
# rearrange label colors if needed
if (!is.null(left.label.col)) {
left.label.col <- left.label.col[order.df.rows$order.rows]
}
if (!is.null(bottom.label.col)) {
bottom.label.col <- bottom.label.col[order.df.cols$order.cols]
}
# rearrange label text colors if needed
if (!is.null(left.label.text.col)) {
left.label.text.col <- left.label.text.col[order.df.rows$order.rows]
}
if (!is.null(bottom.label.text.col)) {
bottom.label.text.col <- bottom.label.text.col[order.df.cols$order.cols]
}
# the default if clustering was not performed
if (ncol(X) == 1) {
membership.cols <- 1
}
if (!cluster.cols & ncol(X) > 1) {
membership.cols <- 1:ncol(X)
} else {
membership.cols <- membership.cols[order.df.cols$order.cols]
}
if (nrow(X) == 1) {
membership.rows <- 1
}
if (!cluster.rows & nrow(X) > 1) {
membership.rows <- 1:nrow(X)
} else {
membership.rows <- membership.rows[order.df.rows$order.rows]
}
# Extract the arguments relevant to the heatmap function
heat.arg.list <- c(as.list(environment()))
# drop exess factor levels
if (!is.null(membership.rows)) {
membership.rows <- as.factor(membership.rows)
membership.rows <- droplevels(membership.rows)
membership.rows <- forcats::fct_inorder(membership.rows)
}
if (!is.null(membership.cols)) {
membership.cols <- as.factor(membership.cols)
membership.cols <- droplevels(membership.cols)
membership.cols <- forcats::fct_inorder(membership.cols)
}
if (row.dendrogram) {
pretty.order.rows = TRUE
}
if (col.dendrogram) {
pretty.order.cols = TRUE
}
# set default title alignment
if (is.null(title.alignment)) {
title.alignment <- "left"
}
# match the arguments to those provided
smoothing.method <- match.arg(smoothing.method)
yt.plot.type <- match.arg(yt.plot.type)
yr.plot.type <- match.arg(yr.plot.type)
heat.col.scheme <- match.arg(heat.col.scheme)
dist.method <- match.arg(dist.method)
linkage.method <- match.arg(linkage.method)
# clean the matrix X
X <- clean_matrix(X, scale)
# run error check on arguments
stop.arg.list <- c(as.list(environment()))
stop.arg.list <- stop.arg.list[names(formals(stopErrors))]
stop.arg.list <- stop.arg.list[!is.na(names(stop.arg.list))]
do.call(stopErrors, stop.arg.list)
# if there is no yt or yr axis name provided, set the name to the name of
# the object provided by the yr/yt argument
if (is.null(yr.axis.name)) {
yr.axis.name <- eval(substitute(internala(yr)))
}
if (is.null(yt.axis.name)) {
yt.axis.name <- eval(substitute(internala(yt)))
}
# if there is a column (row) membership vector or a number of clusters to
# generate is provided, then set cluster.cols to TRUE
if (!is.null(membership.cols) |
(!is.null(n.clusters.cols) && n.clusters.cols > 0)) {
cluster.cols <- TRUE
} else {
cluster.cols <- FALSE
}
if (!is.null(membership.rows) |
(!is.null(n.clusters.rows) && n.clusters.rows > 0)) {
cluster.rows <- TRUE
} else {
cluster.rows <- FALSE
}
# how many column clusters
if (cluster.cols) {
if (!is.null(n.clusters.cols)) {
effective.col.clusters <- n.clusters.cols
} else if (!is.null(membership.cols)) {
effective.col.clusters <- length(unique(membership.cols))
}
}
# how many row clusters
if (cluster.rows) {
if (!is.null(n.clusters.rows)) {
effective.row.clusters <- n.clusters.rows
} else if (!is.null(membership.rows)) {
effective.row.clusters <- length(unique(membership.rows))
}
}
# run error check on clustering mechanism
cluster.stop.arg.list <- c(as.list(environment()))
cluster.stop.arg.list <- cluster.stop.arg.list[names(formals(clusterStopErrors))]
cluster.stop.arg.list <- cluster.stop.arg.list[!is.na(names(cluster.stop.arg.list))]
do.call(clusterStopErrors, cluster.stop.arg.list)
# set the type of label for each additional plot
label.type <- setLabelType(X,
left.label,
cluster.rows,
bottom.label,
cluster.cols,
force.left.label,
force.bottom.label,
yr.obs.col,
yt.obs.col)
bottom.label <- label.type$bottom.label
left.label <- label.type$left.label
# remove the heatmap grid lines if there are more than 50 cols/rows
# do this only when there are variable labels or no labels
# (but we want there to be grid lines when there are more than 50
#  rows/columns but we are grouping by cluster. In this case the grid
#  lines correspond to the clusters rather than the variables)
if (!cluster.cols &
((bottom.label == "variable") | (bottom.label == "none"))) {
if ((ncol(X) > 50) && !force.grid.vline) {
grid.vline <- FALSE
}
}
if (!cluster.rows &
((left.label == "variable") | (left.label == "none"))) {
if ((nrow(X) > 50) && !force.grid.hline) {
grid.hline <- FALSE
}
}
# remove alternating color in adjacent plots if no labels
if (!is.null(yr) && # provided a right-plot
(nrow(X) > 100) &&  # default no labels
!force.left.label && # nor forcing labels
is.null(yr.obs.col) &&  # no point color provided
(length(yr) == nrow(X)) && # right plot is at the individual-level
!cluster.rows) { # did not cluster rows
yr.obs.col <- rep("grey50", nrow(X))
}
if (!is.null(yt) && # provided a top-plot
(ncol(X) > 100) &&  # default no labels
is.null(yt.obs.col) &&  # no point color provided
(length(yt) == ncol(X)) && # top plot is at the individual-level
!cluster.cols) {  # did not cluster cols
yt.obs.col <- rep("grey50", ncol(X))
}
# if cluster.rows is TRUE and no row membership is provided,
# then perform clustering
if (is.null(membership.rows) && cluster.rows) {
# identify the number of row clusters specified
n.clusters <- n.clusters.rows
# perform the clustering
cluster.arg.list <- c(as.list(environment()))
cluster.arg.list <- cluster.arg.list[names(formals(generate_cluster))]
cluster.arg.list <- cluster.arg.list[!is.na(names(cluster.arg.list))]
# extract the membership vector
clustering <- do.call(generate_cluster, cluster.arg.list)
membership.rows <- clustering$membership
hclust.rows <- clustering$clust
}
# if cluster.cols is TRUE and no column membership is provided,
# then perform clustering
if (is.null(membership.cols) && cluster.cols) {
# identify the number of row clusters specified
n.clusters <- n.clusters.cols
# perform the clustering
cluster.arg.list <- c(as.list(environment()))
cluster.arg.list <- cluster.arg.list[names(formals(generate_cluster))]
cluster.arg.list <- cluster.arg.list[!is.na(names(cluster.arg.list))]
cluster.arg.list$X <- t(cluster.arg.list$X)
# extract the membership vector
clustering <- do.call(generate_cluster, cluster.arg.list)
membership.cols <- clustering$membership
hclust.cols <- clustering$clust
}
# note that we must obtain the hierarchical clustering
# after rearranging the order of the rows and columns
if (pretty.order.cols) {
hclust.cols <- hclust(dist(t(X), method = dist.method),
method = linkage.method)
}
if (pretty.order.rows) {
hclust.rows <- hclust(dist(X, method = dist.method),
method = linkage.method)
}
# if there is a pretty.order.rows/cols, order rows/cols by hclust order
if (pretty.order.rows && is.null(order.rows)) {
order.rows <- hclust.rows$order
}
if (pretty.order.cols && is.null(order.cols)) {
order.cols <- hclust.cols$order
}
# if a specific row/col ordering is not provided,
# define the ordering to be that given in the original matrix
if (is.null(order.rows) && (!row.dendrogram)) {
order.rows <- 1:nrow(X)
}
if (is.null(order.cols) && (!col.dendrogram)) {
order.cols <- 1:ncol(X)
}
# make a data frame order.df.rows/cols that contains the membership and order
# of each row/columns.
# if clustering was performed then re-order the rows by cluster
if (cluster.rows) {
order.df.rows <- data.frame(membership.rows = membership.rows[order.rows],
order.rows = order.rows)
order.df.rows <- order.df.rows %>%
dplyr::arrange(membership.rows) %>%
dplyr::ungroup()
} else {
# if there is no clustering, just put all rows in the same cluster
order.df.rows <- data.frame(membership.rows = 1,
order.rows = order.rows)
}
# re-order the columns by cluster
if (cluster.cols) {
order.df.cols <- data.frame(membership.cols = membership.cols[order.cols],
order.cols = order.cols)
order.df.cols <- order.df.cols %>%
dplyr::arrange(membership.cols) %>%
dplyr::ungroup()
} else {
# if there is no clustering, just put all columns in the same cluster
order.df.cols <- data.frame(membership.cols = 1, order.cols = order.cols)
}
# Reorder X matrices, yr and yt based on the new ordering
if (ncol(X) == 1) {
X <- as.matrix(X[order.df.rows$order.rows, ], drop = FALSE)
}
if (nrow(X) == 1) {
X <- as.matrix(X[, order.df.cols$order.cols], drop = FALSE)
}
if (nrow(X) > 1 & ncol(X) > 1) {
X <- X[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text) && is.matrix(X.text) &&
(nrow(X.text) == nrow(X)) &&
(ncol(X.text) == ncol(X))) {
X.text <- X.text[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.col) && is.matrix(X.text.col) &&
(nrow(X.text.col) == nrow(X)) &&
(ncol(X.text.col) == ncol(X))) {
X.text.col <- X.text.col[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.size) && is.matrix(X.text.size) &&
(nrow(X.text.size) == nrow(X)) &&
(ncol(X.text.size) == ncol(X))) {
X.text.size <- X.text.size[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(X.text.angle) && is.matrix(X.text.angle)) {
X.text.angle <- X.text.angle[order.df.rows$order.rows, order.df.cols$order.cols]
}
if (!is.null(yr)) {
# only rearrange within cluster if the right plot is for each
# data point (rather than for each cluster)
if (length(yr) == nrow(X)) {
yr <- yr[order.df.rows$order.rows]
yr.obs.col <- yr.obs.col[order.df.rows$order.rows]
}
}
if (!is.null(yt)) {
# only rearrange within cluster if the top plot is for each
# data point (rather than for each cluster)
if (length(yt) == ncol(X)) {
yt <- yt[order.df.cols$order.cols]
yt.obs.col <- yt.obs.col[order.df.cols$order.cols]
}
}
# rearrange bar colors if needed
if (!is.null(yt.bar.col) && (length(yt.bar.col) == ncol(order.df.cols))) {
yt.bar.col <- yt.bar.col[order.df.cols$order.cols]
}
if (!is.null(yr.bar.col) && (length(yr.bar.col) == nrow(order.df.rows))) {
yr.bar.col <- yr.bar.col[order.df.rows$order.rows]
}
# rearrange label colors if needed
if (!is.null(left.label.col)) {
left.label.col <- left.label.col[order.df.rows$order.rows]
}
if (!is.null(bottom.label.col)) {
bottom.label.col <- bottom.label.col[order.df.cols$order.cols]
}
# rearrange label text colors if needed
if (!is.null(left.label.text.col)) {
left.label.text.col <- left.label.text.col[order.df.rows$order.rows]
}
if (!is.null(bottom.label.text.col)) {
bottom.label.text.col <- bottom.label.text.col[order.df.cols$order.cols]
}
# the default if clustering was not performed
if (ncol(X) == 1) {
membership.cols <- 1
}
if (!cluster.cols & ncol(X) > 1) {
membership.cols <- 1:ncol(X)
} else {
membership.cols <- membership.cols[order.df.cols$order.cols]
}
if (nrow(X) == 1) {
membership.rows <- 1
}
if (!cluster.rows & nrow(X) > 1) {
membership.rows <- 1:nrow(X)
} else {
membership.rows <- membership.rows[order.df.rows$order.rows]
}
# Extract the arguments relevant to the heatmap function
heat.arg.list <- c(as.list(environment()))
heat.arg.list <- heat.arg.list[names(formals(generate_heat))]
heat.arg.list <- heat.arg.list[!is.na(names(heat.arg.list))]
# if heatmap smoothing is specified, use the generate_smooth_heat function,
# otherwise, use the generate_heat function
if (smooth.heat) {
heat <- do.call(generate_smooth_heat, heat.arg.list)
} else {
heat <- do.call(generate_heat, heat.arg.list)
}
# extract the heatmap object from the output
gg.heat <- heat$gg.heat
# extract the legend object from the output
if (legend) {
gg.legend <- heat$gg.legend
}
# Generate the top and right plots
if (!is.null(yt) && (!col.dendrogram)) {
# define all arguments of the top plot
y <- yt
y.obs.col <- yt.obs.col
y.cluster.col <- yt.cluster.col
y.bar.col <- yt.bar.col
y.line.size <- yt.line.size
y.line.col <- yt.line.col
y.lim <- yt.lim
membership <- membership.cols
location <- "top"
axis.name <- yt.axis.name
axis.size <- yt.axis.size
axis.name.size <- yt.axis.name.size
axis.name.angle <- yt.axis.name.angle
point.size <- yt.point.size
point.alpha <- yt.point.alpha
plot.type <- yt.plot.type
num.ticks <- yt.num.ticks
# generate the top plot
# identify variables defined in the environment
plot.arg.list <- c(as.list(environment()))
# identify the possible arguments for generate_add_on_plot
plot.arg.list <- plot.arg.list[names(formals(generate_add_on_plot))]
# filter the variables in the environment to those that are arguments
# for generate_add_on_plot
plot.arg.list <- plot.arg.list[!is.na(names(plot.arg.list))]
gg.top <- do.call(generate_add_on_plot, plot.arg.list)
} else if (col.dendrogram) {
suppressMessages(gg.top <- ggdendro::ggdendrogram(hclust.cols) +
ggplot2::scale_x_continuous(expand = c(1/(2 * ncol(X)), 1/(2 * ncol(X)))))
}
